[{"id":29,"title":"内置组件","routePath":"/zh/api/client-api/api-components","lang":"zh","toc":[{"text":"NoSSR","id":"nossr","depth":2,"charIndex":3},{"text":"Tab/Tabs","id":"tabtabs","depth":2,"charIndex":118}],"domain":"","content":"#\n\n\nNoSSR#\n\n用于在服务端渲染时不渲染某些组件。使用方法如下：\n\n\n\nconst Component = () => {\n  return (\n    \n      \n这里的内容只会在客户端渲染\n    \n  );\n};\n\n\n\nTab/Tabs#\n\n你可以在文档中直接使用 Tab/Tabs 组件来实现 tab 切换的效果。比如\n\n\n\nfunction App() {\n  return (\n    \n      Tab 1 content\n      Tab 2 content\n    \n  );\n}\n\n\n提醒\n\n为了让你更方便地使用这些组件，框架内部对于 rspress/theme 这个包做了 alias 处理，所以你可以直接使用 @theme 来引入这些组件。\n\n其中 Tabs 组件的 props 类型如下:\n\ninterface TabsProps {\n  children: React.ReactNode;\n  defaultValue?: string;\n  groupId?: string;\n}\n\n\ndefaultValue 用于设置默认选中的 tab 项，这个值会和 Tab 组件的 value 字段做比较，如果相等则选中该 tab。\n\ngroupId 用于设置 tab 项的分组，当你需要多个 Tabs 组件进行联动的时候，可以通过 groupId 来实现。groupId 相同的 Tabs\n组件会进行联动。\n\nTab 组件的 props 类型如下:\n\ninterface TabProps {\n  label: string;\n  // 用于标识当前 tab，如果不传则默认使用 label\n  value?: string;\n  children: React.ReactNode;\n}\n\n\n其中的 value 字段用于标识当前 tab，如果不传则默认使用 label。","frontmatter":{}},{"id":30,"title":"Runtime API","routePath":"/zh/api/client-api/api-runtime","lang":"zh","toc":[{"text":"usePageData","id":"usepagedata","depth":2,"charIndex":38},{"text":"useLang","id":"uselang","depth":2,"charIndex":185},{"text":"useDark","id":"usedark","depth":2,"charIndex":318},{"text":"useI18n","id":"usei18n","depth":2,"charIndex":428},{"text":"路由 Hook","id":"路由-hook","depth":2,"charIndex":854}],"domain":"","content":"#\n\nRspress 暴露一些运行时 API，方便你做一些自定义的逻辑。\n\n\nusePageData#\n\n获取当前页面的数据，返回值为一个对象，包含了当前页面的所有数据。\n\n\n\nfunction MyComponent() {\n  const pageData = usePageData();\n  return \n{pageData.page.title};\n}\n\n\n\nuseLang#\n\n获取当前语言，返回值为一个字符串，即当前语言。\n\n\n\nfunction MyComponent() {\n  const lang = useLang();\n  // lang === 'zh-CN'\n  return \n{lang};\n}\n\n\n\nuseDark#\n\n当前主题是否为暗黑模式，返回值为一个布尔值。\n\n\n\nfunction MyComponent() {\n  const dark = useDark();\n  return \n{dark};\n}\n\n\n\nuseI18n#\n\n框架提供了 useI18n 这个 hook 来获取国际化文本，使用方式如下：\n\n\n\nconst MyComponent = () => {\n  const { t } = useI18n();\n\n  return \n{t('getting-started')};\n};\n\n\n为了获得更好的类型提示，你可以在 tsconfig.json 中配置 paths:\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"i18n\": [\"./i18n.json\"]\n    }\n  }\n}\n\n\n然后在组件中这样使用:\n\n\n\nconst MyComponent = () => {\n  const { t } = useI18n();\n\n  return \n{t('getting-started')};\n};\n\n\n这样你就可以获得 i18n.json 中定义的所有文本 key 的类型提示了。\n\n\n路由 Hook#\n\n框架内部使用并重导出了 react-router-dom 的所有 API，你可以这样来使用:\n\n\n\nfunction MyComponent() {\n  const location = useLocation();\n  return \n{location.pathname};\n}\n","frontmatter":{}},{"id":31,"title":"命令","routePath":"/zh/api/commands","lang":"zh","toc":[{"text":"rspress dev","id":"rspress-dev","depth":2,"charIndex":46},{"text":"rspress build","id":"rspress-build","depth":2,"charIndex":220},{"text":"rspress preview","id":"rspress-preview","depth":2,"charIndex":374}],"domain":"","content":"#\n\n通过本章节，你可以了解到 Rspress 内置的命令有哪些，以及如何使用这些命令。\n\n\nrspress dev#\n\nrspress dev 命令用于启动一个本地开发服务器，提供一个文档进行预览和调试的开发环境。\n\nUsage: rspress dev [options]\n\nOptions:\n  -c --config   指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help            显示命令帮助\n\n\n\nrspress build#\n\nrspress build 命令用于构建出针对生产环境的文档产物。\n\nUsage: rspress build [options]\n\nOptions:\n  -c --config   指定配置文件路径，可以为相对路径或绝对路径\n  -h, --help  显示命令帮助\n\n\n\nrspress preview#\n\nrspress preview 命令用于在本地预览 rspress build 命令构建出的产物。\n\nUsage: rspress preview [options]\n\nOptions:\n  -c --config   指定配置文件路径，可以为相对路径或绝对路径\n  --port          指定端口号\n  --host          指定 host\n  -h, --help  显示命令帮助\n","frontmatter":{}},{"id":32,"title":"基础配置","routePath":"/zh/api/config/config-basic","lang":"zh","toc":[{"text":"base","id":"base","depth":2,"charIndex":3},{"text":"title","id":"title","depth":2,"charIndex":174},{"text":"description","id":"description","depth":2,"charIndex":306},{"text":"icon","id":"icon","depth":2,"charIndex":442},{"text":"logo","id":"logo","depth":2,"charIndex":618},{"text":"outDir","id":"outdir","depth":2,"charIndex":968},{"text":"locales","id":"locales","depth":2,"charIndex":1096},{"text":"mediumZoom","id":"mediumzoom","depth":2,"charIndex":1520},{"text":"search","id":"search","depth":2,"charIndex":1853},{"text":"globalUIComponents","id":"globaluicomponents","depth":2,"charIndex":2238}],"domain":"","content":"#\n\n\nbase#\n\n * Type: string\n * Default: /\n\n部署基准路径。比如，如果你计划将你的站点部署到 https://foo.github.io/bar/，那么你应该将 base 设置为 \"/bar/\"：\n\n\n\nexport default defineConfig({\n  base: '/bar/',\n});\n\n\n\ntitle#\n\n * Type: string\n * Default: \"Island\"\n\n站点标题。这个参数将被用作 HTML 页面的标题。例如：\n\n\n\nexport default defineConfig({\n  title: '我的站点',\n});\n\n\n\ndescription#\n\n * Type: string\n * Default: \"\"\n\n站点描述。这将用作 HTML 页面的描述。例如：\n\n\n\nexport default defineConfig({\n  description: '我的站点描述',\n});\n\n\n\nicon#\n\n * Type: string\n * Default: \"\"\n\n站点图标。这个路径将用作 HTML 页面的图标路径。例如：\n\n\n\nexport default defineConfig({\n  icon: '/favicon.ico',\n});\n\n\n框架会在 public 目录中找到你的图标，当然你也可以设置成一个 CDN 地址。\n\n\nlogo#\n\n * Type: string | { dark: string; light: string }\n * Default: \"\"\n\n站点 logo。这个路径将用作导航栏左上角的 logo 路径。例如：\n\n\n\nexport default defineConfig({\n  logo: '/logo.png',\n});\n\n\n框架会在 public 目录中找到你的图标，当然你也可以设置成一个 CDN 地址。\n\n当然你可以针对浅色/暗黑模式设置不同的 logo：\n\n\n\nexport default defineConfig({\n  logo: {\n    dark: '/logo-dark.png',\n    light: '/logo-light.png',\n  },\n});\n\n\n\noutDir#\n\n * Type: string\n * Default: doc_build\n\n自定义构建站点的输出目录。比如:\n\n\n\nexport default defineConfig({\n  outDir: 'doc_build',\n});\n\n\n\nlocales#\n\n * Type: Locale[]\n\nexport interface Locale {\n  lang: string;\n  label: string;\n  title?: string;\n  description?: string;\n}\n\n\n站点的多语言配置。比如：\n\n\n\nexport default defineConfig({\n  locales: [\n    {\n      lang: 'en-US',\n      label: 'English',\n      title: 'Doc Tools',\n      description: 'Doc Tools',\n    },\n    {\n      lang: 'zh-CN',\n      label: '简体中文',\n      title: '文档框架',\n      description: '文档框架',\n    },\n  ],\n});\n\n\n\nmediumZoom#\n\n * Type: boolean | { selector?: string }\n * Default: true\n\n是否开启图片放大功能。默认开启，你可以通过设置 mediumZoom 为 false 来关闭。\n\n> 底层使用的是 medium-zoom 库来实现的。\n\n使用示例：\n\n\n\nexport default defineConfig({\n  // 关闭图片放大功能\n  mediumZoom: false,\n  // 配置 CSS 选择器，自定义要放大的图片，默认为 '.modern-doc img'\n  mediumZoom: {\n    selector: '.modern-doc img',\n  },\n});\n\n\n\nsearch#\n\n * Type: { searchHooks: string }\n\n你可以通过 searchHooks 参数来增加搜索运行时钩子逻辑，比如：\n\n\n\n\nexport default defineConfig({\n  search: {\n    searchHooks: path.join(__dirname, 'searchHooks.ts'),\n  },\n});\n\n\nsearchHooks.ts 中，你需要导出 onSearch 函数，这个函数将会在每次搜索时被调用，入参为搜索关键词，你可以在这里自定义搜索拦截逻辑，比如：\n\n// 支持 async 函数\nexport async function onSearch(query: string) {\n  // 执行自定义逻辑，比如打点上报\n  console.log(query);\n}\n\n\n\nglobalUIComponents#\n\n * Type: string[]\n * Default: []\n\n你可以通过 globalUIComponents 参数来增加全局 UI 组件，比如：\n\n\n\n\nexport default defineConfig({\n  globalUIComponents: [path.join(__dirname, 'components', 'MyComponent.tsx')],\n});\n\n\n当你注册了全局组件之后，框架会自动将这些 React 组件在主题中进行渲染，而不用你手动引入。\n\n通过全局组件，你可以完成诸多自定义的功能，比如:\n\n\n\n// 需要默认导出一个组件\nexport default function PluginUI() {\n  return \n这是一个全局的布局组件;\n}\n\n\n这样，在主题页面中会渲染组件的内容，比如添加回到顶部按钮。\n\n同时，你也可以通过全局组件来注册全局副作用。比如：\n\n\n\n\n// 需要默认导出一个组件\nexport default function PluginSideEffect() {\n  const { pathname } = useLocation();\n  useEffect(() => {\n    // 组件初次渲染时执行\n  }, []);\n\n  useEffect(() => {\n    // 路由变化时执行\n  }, [pathname]);\n  return null;\n}\n\n\n这样，在主题页面中会执行组件的副作用。比如以下的一些需要副作用的场景:\n\n * 针对某些页面路由进行重定向操作。\n * 对页面的 img 标签进行事件监听，实现图片放大功能。\n * 路由变化时，上报不同页面的 PV 数据。\n * ......","frontmatter":{}},{"id":33,"title":"构建配置","routePath":"/zh/api/config/config-build","lang":"zh","toc":[{"text":"builderConfig","id":"builderconfig","depth":2,"charIndex":3},{"text":"builderPlugins","id":"builderplugins","depth":2,"charIndex":258},{"text":"默认配置","id":"默认配置","depth":3,"charIndex":416},{"text":"markdown","id":"markdown","depth":2,"charIndex":658},{"text":"markdown.remarkPlugins","id":"markdownremarkplugins","depth":3,"charIndex":704},{"text":"markdown.rehypePlugins","id":"markdownrehypeplugins","depth":3,"charIndex":975},{"text":"markdown.checkDeadLinks","id":"markdowncheckdeadlinks","depth":3,"charIndex":1231},{"text":"markdown.experimentalMdxRs","id":"markdownexperimentalmdxrs","depth":3,"charIndex":1444},{"text":"markdown.showLineNumbers","id":"markdownshowlinenumbers","depth":3,"charIndex":1759},{"text":"markdown.globalComponents","id":"markdownglobalcomponents","depth":3,"charIndex":1828}],"domain":"","content":"#\n\n\nbuilderConfig#\n\n * Type: Object\n\n用于自定义 Modern.js Builder 的配置项，完整配置项请查看 Modern.js Builder - API。\n\n比如，将产物目录修改为 doc_dist：\n\nexport default defineConfig({\n  builderConfig: {\n    output: {\n      distPath: {\n        root: 'doc_dist',\n      },\n    },\n  },\n});\n\n\n\nbuilderPlugins#\n\n * Type: BuilderPlugin[]\n\n用于加入 Modern.js Builder 的插件，比如：\n\n\n\n\nexport default defineConfig({\n  builderPlugins: [builderPluginStylus()],\n});\n\n\n\n默认配置#\n\n如果你需要查看默认的 builderConfig，可以在执行 rspress dev 或 rspress build 命令时，添加 DEBUG=builder\n参数：\n\nDEBUG=builder rspress dev\n\n\n在执行后，doc_build 目录下会生成 builder.config.js 文件，里面包含了完整的 builderConfig。\n\n> 请查看 Modern.js Builder - 调试模式 来了解更多调试 Builder 的方法。\n\n\nmarkdown#\n\n * Type: Object\n\n配置 MDX 相关的编译能力。\n\n\nmarkdown.remarkPlugins#\n\n * Type: Array\n * Default: []\n\n配置 remark 插件。比如：\n\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [\n      [\n        require('remark-autolink-headings'),\n        {\n          behavior: 'wrap',\n        },\n      ],\n    ],\n  },\n});\n\n\n\nmarkdown.rehypePlugins#\n\n * Type: Array\n\n配置 rehype 插件。比如：\n\n\n\nexport default defineConfig({\n  markdown: {\n    rehypePlugins: [\n      [\n        require('rehype-autolink-headings'),\n        {\n          behavior: 'wrap',\n        },\n      ],\n    ],\n  },\n});\n\n\n\nmarkdown.checkDeadLinks#\n\n * Type: boolean\n * Default: false\n\n是否检查死链。比如：\n\n\n\nexport default defineConfig({\n  markdown: {\n    checkDeadLinks: true,\n  },\n});\n\n\n开启这个配置后，框架会基于约定式路由表对文档中的链接进行检查，若出现无法访问的链接，构建会抛出错误并退出。\n\n\nmarkdown.experimentalMdxRs#\n\n * Type: boolean\n\n是否使用 MDX 的 Rust 版本编译器，为实验性质功能。比如：\n\n\n\nexport default defineConfig({\n  markdown: {\n    experimentalMdxRs: true,\n  },\n});\n\n\n注意\n\n这个功能底层基于 Rspress 自研的 @modern-js/mdx-rs-binding 库来实现，性能比 JS 版本的 MDX 编译器高 5 ~ 10\n倍，但目前还不支持 JS 版本的插件，如果你需要加入自定义的 remark 或 rehype 插件，建议不要开启这个功能。\n\n\nmarkdown.showLineNumbers#\n\n * Type: boolean\n\n是否显示代码块的行号。默认为 false。\n\n\nmarkdown.globalComponents#\n\n * Type: string[]\n\n注册全局组件，无需通过导入声明，就可以在每个 MDX 文件中使用。比如：\n\n\n\n\nexport default defineConfig({\n  markdown: {\n    globalComponents: [path.join(__dirname, 'src/src/components/Alert.tsx')],\n  },\n});\n\n\n这样你就可以在 MDX 文件中使用 Alert 组件了：\n\nThis is a info alert\n\n\n警告\n\n请勿在配置 globalComponents 时开启 experimentalMdxRs，否则会导致全局组件不生效。","frontmatter":{}},{"id":34,"title":"Front Matter 配置","routePath":"/zh/api/config/config-frontmatter","lang":"zh","toc":[{"text":"title","id":"title","depth":2,"charIndex":3},{"text":"description","id":"description","depth":2,"charIndex":134},{"text":"pageType","id":"pagetype","depth":2,"charIndex":210},{"text":"hero","id":"hero","depth":2,"charIndex":569},{"text":"features","id":"features","depth":2,"charIndex":1118},{"text":"sidebar","id":"sidebar","depth":2,"charIndex":1677},{"text":"outline","id":"outline","depth":2,"charIndex":1788},{"text":"footer","id":"footer","depth":2,"charIndex":1876},{"text":"hideNavbar","id":"hidenavbar","depth":2,"charIndex":1981}],"domain":"","content":"#\n\n\ntitle#\n\n * Type: string\n\n页面的标题。默认情况下，页面的 h1 标题将用作 HTML 文档的标题。但是如果你想使用不同的标题，你可以使用 Front Matter\n来指定页面的标题。例如：\n\n---\ntitle: 我的主页\n---\n\n\n\ndescription#\n\n * Type: string\n\n页面的自定义描述。例如：\n\n---\ndescription: 这是我的主页\n---\n\n\n\npageType#\n\n * Type: 'home' | 'doc' | 'custom' | 'blank' | '404'\n * Default: 'doc'\n\n页面的类型。默认情况下，页面类型为doc。但是如果你想使用不同的页面类型，你可以使用pageType这个 Front Matter 字段来指定页面类型。例如：\n\n---\npageType: home\n---\n\n\n各个pageType配置的含义如下：\n\n * home: 首页，包含顶部导航栏和首页的布局内容。\n * doc: 文档页，包含顶部导航栏、左边侧边栏、正文内容和右侧的大纲栏。\n * custom: 自定义页面，包含顶部导航栏和自定义的内容。\n * blank: 也属于自定义页面，但是不包含顶部导航栏。\n * 404: 404 页面。\n\n\nhero#\n\n * Type: Object\n\nhome 页面的 hero 配置。它有以下类型：\n\nexport interface Hero {\n  name: string;\n  text: string;\n  tagline: string;\n  image?: {\n    src: string;\n    alt: string;\n  };\n  actions: {\n    text: string;\n    link: string;\n    theme: 'brand' | 'alt';\n  }[];\n}\n\n\n例如，你可以使用以下 Front Matter 来指定页面的 hero config：\n\n---\npageType: home\n\nhero:\n  name: Rspress\n  text: 文档工程解决方案\n  tagline: 现代化文档开发技术栈\n  actions:\n    - theme: brand\n      text: 介绍\n      link: /zh/guide/introduction\n    - theme: alt\n      text: 快速开始\n      link: /zh/guide/getting-started\n---\n\n\n\nfeatures#\n\n * Type: Array\n * Default: []\n\nhome 页面的功能配置。它有以下类型：\n\nexport interface Feature {\n  title: string;\n  details: string;\n  icon: string;\n  // feature 卡片跳转链接，选填\n  link?: string;\n}\n\nexport type Features = Feature[];\n\n\n例如，你可以使用以下内容来指定 home 页面的 features 配置：\n\n---\npageType: home\n\nfeatures:\n  - title: 'MDX: 使用灵活语法编写内容'\n    details: MDX 是一种强大的内容编写方式，你可以在 Markdown 中使用 React 组件。\n    icon: 📦\n  - title: '功能丰富: 一站式解决方案'\n    details: 对全文搜索、国际化等常见功能可以做到开箱即用。\n    icon: 🎨\n  - title: '扩展性强: 提供多种自定义能力'\n    details: 通过其扩展机制，你可以轻松的扩展主题 UI 和构建能力。\n    icon: 🚀\n---\n\n\n\nsidebar#\n\n是否展示左侧的目录栏。默认情况下，doc 页面会展示左侧的目录栏。但是如果你想隐藏左侧的目录栏，你可以使用以下 Front Matter 来配置：\n\n---\nsidebar: false\n---\n\n\n\noutline#\n\n是否展示右侧的大纲栏。默认情况下，doc 页面会展示右侧的大纲栏。你可以通过下面的配置来隐藏大纲栏：\n\n---\noutline: false\n---\n\n\n\nfooter#\n\n是否展示文档底部的组件(如上一页/下一页)。默认情况下，doc 页面会展示底部的 footer。你可以通过下面的配置来隐藏 footer：\n\n---\nfooter: false\n---\n\n\n\nhideNavbar#\n\n是否隐藏顶部导航栏。默认情况下，所有页面都会展示顶部导航栏。但是如果你想隐藏顶部导航栏，你可以使用以下 Front Matter 来配置：\n\n---\nhideNavbar: true\n---\n","frontmatter":{}},{"id":35,"title":"主题配置","routePath":"/zh/api/config/config-theme","lang":"zh","toc":[{"text":"nav","id":"nav","depth":2,"charIndex":109},{"text":"sidebar","id":"sidebar","depth":2,"charIndex":1214},{"text":"footer","id":"footer","depth":2,"charIndex":2459},{"text":"outlineTitle","id":"outlinetitle","depth":2,"charIndex":2736},{"text":"lastUpdated","id":"lastupdated","depth":2,"charIndex":2906},{"text":"lastUpdatedText","id":"lastupdatedtext","depth":2,"charIndex":3067},{"text":"prevPageText","id":"prevpagetext","depth":2,"charIndex":3242},{"text":"socialLinks","id":"sociallinks","depth":2,"charIndex":3408},{"text":"nextPageText","id":"nextpagetext","depth":2,"charIndex":4630},{"text":"locales","id":"locales","depth":2,"charIndex":4788},{"text":"darkMode","id":"darkmode","depth":2,"charIndex":5446},{"text":"hideNavbar","id":"hidenavbar","depth":2,"charIndex":5596}],"domain":"","content":"#\n\n主题配置位于 doc 配置中的 themeConfig 下。例如：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    // ...\n  },\n});\n\n\n\nnav#\n\n * Type: Array\n * Default: []\n\n网站的导航栏。 nav 配置是 NavItem 的数组，具有以下类型：\n\ninterface NavItem {\n  // 导航栏文本\n  text: string;\n  // 导航栏链接\n  link: '/';\n  // 导航栏链接的激活规则\n  activeMatch: '^/$|^/';\n  // 图标配置(可选)，填入 svg 标签内容或者图片 URL\n  tag?: string;\n}\n\n\nactiveMatch 用于匹配当前路由，当路由匹配 activeMatch 规则时，nav 项会高亮显示。默认情况下，activeMatch 是 nav 项的\nlink。\n\n比如:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    nav: [\n      {\n        text: 'Home',\n        link: '/',\n      },\n      {\n        text: 'Guide',\n        link: '/guide/',\n      },\n    ],\n  },\n});\n\n\n当然 nav 数组中也可以配置多级菜单，类型如下:\n\ninterface NavGroup {\n  // 导航栏文本\n  text: string;\n  // 子菜单\n  items: NavItem[];\n  // 图标配置(可选)，填入 svg 标签内容或者图片 URL\n  tag?: string;\n}\n\n\n例如下面的配置:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    nav: [\n      {\n        text: 'Home',\n        link: '/',\n      },\n      {\n        text: 'Guide',\n        items: [\n          {\n            text: 'Getting Started',\n            link: '/guide/getting-started',\n          },\n          {\n            text: 'Advanced',\n            link: '/guide/advanced',\n          },\n        ],\n      },\n    ],\n  },\n});\n\n\n\nsidebar#\n\n * Type: Object\n\n网站的侧边栏。配置为一个对象，类型如下：\n\n// key 为 SidebarGroup 的路径\n// value 为 SidebarGroup 的数组\ntype Sidebar = Record;\n\ninterface SidebarGroup {\n  text: string;\n  link?: string;\n  items: SidebarItem[];\n  // 是否可折叠\n  collapsible?: boolean;\n  // 是否默认折叠\n  collapsed?: boolean;\n  // 图标配置(可选)，填入 svg 标签内容或者图片 URL\n  tag?: string;\n}\n\n// 可填入一个对象，也可以填入一个字符串\n// 填入字符串时，内部会转换成一个对象，字符串会被当做 link，text 值会自动取对应文档的标题\ntype SidebarItem =\n  | {\n      // 侧边栏文本\n      text: string;\n      // 侧边栏链接\n      link: string;\n      // 图标配置(可选)，填入 svg 标签内容或者图片 URL\n      tag?: string;\n    }\n  | string;\n\n\n比如:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    sidebar: {\n      '/guide/': [\n        {\n          text: 'Getting Started',\n          items: [\n            // 填入一个对象\n            {\n              text: 'Introduction',\n              link: '/guide/getting-started/introduction',\n            },\n            {\n              text: 'Installation',\n              link: '/guide/getting-started/installation',\n            },\n          ],\n        },\n        {\n          text: 'Advanced',\n          items: [\n            // 直接填入链接字符串\n            '/guide/advanced/customization',\n            '/guide/advanced/markdown',\n          ],\n        },\n      ],\n    },\n  },\n});\n\n\n\nfooter#\n\n * Type: Object\n * Default: {}\n\n主页的页脚。\n\nfooter 配置是 Footer 的一个对象，它具有以下类型：\n\nexport interface Footer {\n  message?: string;\n  copyright?: string;\n}\n\n\n比如：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    footer: {\n      message: 'This is a footer',\n    },\n  },\n});\n\n\n\noutlineTitle#\n\n * Type: string\n * Default: 'ON THIS PAGE'\n\n在右侧边栏中配置大纲的标题。\n\n比如:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    outlineTitle: 'Outline',\n  },\n});\n\n\n\nlastUpdated#\n\n * Type: boolean\n * Default: false\n\n是否显示最后更新时间，默认情况下不显示。\n\n比如:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    lastUpdated: true,\n  },\n});\n\n\n\nlastUpdatedText#\n\n * Type: string\n * Default: Last Updated\n\n最后更新时间的文本。\n\n比如:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    lastUpdatedText: 'Last Updated',\n  },\n});\n\n\n\nprevPageText#\n\n * Type: string\n * Default: Previous Page\n\n上一页的文本。比如:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    prevPageText: 'Previous Page',\n  },\n});\n\n\n\nsocialLinks#\n\n * Type: Array\n * Default: []\n\n你可以通过如下的配置添加相关链接，比如 github 链接、twitter 链接等。 相关链接支持三种模式：链接模式link 文本模式text\n图片模式img，相关例子如下：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    socialLinks: [\n      {\n        icon: 'github',\n        mode: 'link',\n        content: 'https://github.com/sanyuan0704/island.js',\n      },\n      {\n        icon: 'wechat',\n        mode: 'text',\n        content: '微信号xxx',\n      },\n      {\n        icon: 'qq',\n        mode: 'img',\n        content: '/qrcode.png',\n      },\n    ],\n  },\n});\n\n\n * 当link模式时，点击 icon 即可跳转链接。\n * 当text模式时，鼠标移到 icon 上会显示弹框，弹框内容是输入的文本。\n * 当img模式时，鼠标移到 icon 上会显示弹框，弹框内容是指定的图片，需要注意的是，图片需要放在public目录下。\n\n相关链接支持以下几种图片，通过 icon 属性来选择：\n\nexport type SocialLinkIcon =\n  | 'lark'\n  | 'discord'\n  | 'facebook'\n  | 'github'\n  | 'instagram'\n  | 'linkedin'\n  | 'slack'\n  | 'twitter'\n  | 'youtube'\n  | 'weixin'\n  | 'qq'\n  | 'juejin'\n  | 'zhihu'\n  | 'bilibili'\n  | 'weibo'\n  | 'gitlab'\n  | { svg: string };\n\n\n如果需要自定义 icon，可以通过传入一个带有svg属性的对象，svg 的值为自定义图标内容即可，比如：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    socialLinks: [\n      {\n        icon: {\n          svg: 'svg图标内容',\n        },\n        mode: 'link',\n        content: 'https://github.com/',\n      },\n    ],\n  },\n});\n\n\n\nnextPageText#\n\n * Type: string\n * Default: Next Page\n\n下一页的文本。比如:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    nextPageText: 'Next Page',\n  },\n});\n\n\n\nlocales#\n\n * Type: Array\n * Default: undefined\n\n国际化配置。此配置为一个数组，数组中的每一项都是一个 LocaleConfig 对象，它具有以下类型：\n\nexport interface LocaleConfig {\n  /**\n   * 通用站点信息，优先级高于 `locales` 中的配置\n   */\n  // 语言名称\n  lang?: string;\n  // HTML 标题，优先于 `themeConfig.title`\n  title?: string;\n  // HTML 描述，优先于 `themeConfig.description`\n  description?: string;\n  // 对应语言的显示文本\n  label: string;\n  /**\n   * 主题相关信息\n   */\n  // 右侧大纲标题\n  outlineTitle?: string;\n  // 是否显示右侧大纲\n  outline?: boolean;\n  // 最后更新时间文本\n  lastUpdatedText?: string;\n  // 是否显示最后更新时间\n  lastUpdated?: boolean;\n  // 上一页文本\n  prevPageText?: string;\n  // 下一页文本\n  nextPageText?: string;\n}\n\n\nLocaleConfig 中包含许多与主题配置中相同的配置项，但它的优先级会更高。\n\n\ndarkMode#\n\n * Type: boolean\n * Default: true\n\n是否出现暗黑模式/白天模式切换按钮。比如：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    darkMode: true,\n  },\n});\n\n\n\nhideNavbar#\n\n * Type: boolean\n * Default: false\n\n用来隐藏导航栏。比如：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    hideNavbar: true,\n  },\n});\n","frontmatter":{}},{"id":36,"title":"","routePath":"/zh/api/","lang":"zh","toc":[],"domain":"","content":"","frontmatter":{"overview":true}},{"id":37,"title":"自定义主题","routePath":"/zh/guide/advanced/custom-theme","lang":"zh","toc":[{"text":"基于默认主题的扩展","id":"基于默认主题的扩展","depth":2,"charIndex":25},{"text":"1. 基本结构","id":"1-基本结构","depth":3,"charIndex":134},{"text":"2. 使用插槽","id":"2-使用插槽","depth":3,"charIndex":523},{"text":"3. 自定义组件","id":"3-自定义组件","depth":3,"charIndex":1422},{"text":"重新开发自定义主题","id":"重新开发自定义主题","depth":2,"charIndex":1778},{"text":"1. 基本结构","id":"1-基本结构-1","depth":3,"charIndex":1824},{"text":"2. 运行时 API","id":"2-运行时-api","depth":3,"charIndex":2551},{"text":"usePageData","id":"usepagedata","depth":4,"charIndex":2564},{"text":"useLang","id":"uselang","depth":4,"charIndex":2688},{"text":"Content","id":"content","depth":4,"charIndex":2787},{"text":"路由 Hook","id":"路由-hook","depth":4,"charIndex":2873}],"domain":"","content":"#\n\n本文所要介绍的是如何开发一套自定义主题。\n\n\n基于默认主题的扩展#\n\n大部分情况下，你并不想从零开始开发一个主题，而是想基于默认主题进行扩展，这时候可以参考下面的方式进行主题开发。\n\nTIP\n\n如果你想从头开发一套自定义主题，可以前往【重新开发自定义主题】。\n\n\n1. 基本结构#\n\n默认情况下，你需要在项目根目录下创建一个 theme 目录，然后在 theme 目录下创建一个 index.ts 或者 index.tsx\n文件，该文件用于导出主题配置。\n\n├── theme\n│   └── index.tsx\n\n\n你可以使用如下的方式来书写 theme/index.tsx 文件:\n\n\n\nconst Layout = () => some content} />;\n\nexport default {\n  ...Theme,\n  Layout,\n};\n\nexport * from 'rspress/theme';\n\n\n一方面你需要通过 export default 导出一个主题配置对象，另一方面你需要通过 export * from 'rspress/theme'\n导出所有具名导出的内容，这样才能保证你的主题配置能够正常工作。\n\n\n2. 使用插槽#\n\n值得注意的是，Layout 组件设计了一系列的 props 支持插槽元素，你可以通过这些 props 来扩展默认主题的布局，比如将上面的 Layout\n组件改成如下的形式:\n\n\n\n// 以下展示所有的 Props\nconst Layout = () => (\n  beforeHero}\n    /* Home 页 Hero 部分之后 */\n    afterHero={\nafterHero}\n    /* Home 页 Features 部分之前 */\n    beforeFeatures={\nbeforeFeatures}\n    /* Home 页 Features 部分之后 */\n    afterFeatures={\nafterFeatures}\n    /* 正文页 Footer 部分之前 */\n    beforeDocFooter={\nbeforeDocFooter}\n    /* 正文页最前面 */\n    beforeDoc={\nbeforeDoc}\n    /* 正文页最后面 */\n    afterDoc={\nafterDoc}\n    /* 导航栏之前 */\n    beforeNav={\nbeforeNav}\n    /* 左上角导航栏标题之前 */\n    beforeNavTitle={😄}\n    /* 左上角导航栏标题之后 */\n    afterNavTitle={\nafterNavTitle}\n    /* 右侧大纲栏上面 */\n    beforeOutline={\nbeforeOutline}\n    /* 右侧大纲栏下面 */\n    afterOutline={\nafterOutline}\n    /* 整个页面最顶部 */\n    top={\ntop}\n    /* 整个页面最底部 */\n    bottom={\nbottom}\n  />\n);\n\nexport default {\n  ...Theme,\n  Layout,\n};\n\nexport * from 'rspress/theme';\n\n\n\n3. 自定义组件#\n\n要扩展默认主题的组件，除了插槽，你还可以自定义 Home 页面及 404 页面组件，比如:\n\n\n\nconst Layout = () => some content} />;\n\n// 定制 Home 页面\nconst HomeLayout = () => \nHome;\n// 定制 404 页面\nconst NotFoundLayout = () => \n404;\n\nexport default {\n  ...Theme,\n  Layout,\n  HomeLayout,\n  NotFoundLayout,\n};\n\nexport * from 'rspress/theme';\n\n\n当然，在开发过程可能需要使用页面的数据，你可以通过 usePageData 这个 Hook 来获取。\n\n\n重新开发自定义主题#\n\n如果你要从头开始开发一个自定义主题，你需要了解一下主题的组成。\n\n\n1. 基本结构#\n\n默认情况下，你需要在项目根目录下创建一个 theme 目录，然后在 theme 目录下创建一个 index.ts 或者 index.tsx\n文件，该文件用于导出主题配置。\n\n├── theme\n│   └── index.tsx\n\n\n在theme/index.tsx文件中，你需要导出一个 Layout 组件，这个组件就是你的主题的入口组件:\n\n// theme/index.tsx\nfunction Layout() {\n  return \nCustom Theme Layout;\n}\n\n// setup 函数，会在页面初始化时调用，一般用来做全局事件的监听，可为空函数\nconst setup = () => {};\n\n// 导出 Layout 组件和 setup 函数\n// 两者必须导出\nexport { Layout, setup };\n\n\n这个 Layout 组件会被用来渲染整个文档站点的布局，你可以在这个组件中引入你的自定义组件，比如:\n\n// theme/index.tsx\n\n\nfunction Layout() {\n  return (\n    \n\n      \n      \nCustom Theme Layout\n    \n  );\n}\n\nconst setup = () => {};\n\nexport { Layoutm, setup };\n\n// theme/Navbar.tsx\nexport function Navbar() {\n  return \nCustom Navbar;\n}\n\n\n那么问题来了，主题组件是如何获取页面数据和正文 MDX 组件内容的呢？接下来我们来看看相关的 API。\n\n\n2. 运行时 API#\n\nusePageData#\n\n获取站点所有数据的信息，比如:\n\n\n\nfunction MyComponent() {\n  const pageData = usePageData();\n  return \n{pageData.title};\n}\n\n\nuseLang#\n\n获取当前语言信息，比如:\n\n\n\nfunction MyComponent() {\n  const lang = useLang();\n  return \n{lang};\n}\n\n\nContent#\n\n正文 MDX 组件内容，如:\n\n\n\nfunction Layout() {\n  return (\n    \n\n      \n    \n  );\n}\n\n\n路由 Hook#\n\n框架内部用 react-router-dom 来实现路由，所以你可以直接使用 react-router-dom 的 Hook，比如:\n\n\n\nfunction Layout() {\n  const location = useLocation();\n  return \nCurrent location: {location.pathname};\n}\n","frontmatter":{}},{"id":38,"title":"构建能力扩展","routePath":"/zh/guide/advanced/extend-build","lang":"zh","toc":[{"text":"Modern.js Builder","id":"modernjs-builder","depth":2,"charIndex":3},{"text":"MDX 编译插件","id":"mdx-编译插件","depth":2,"charIndex":531}],"domain":"","content":"#\n\n\nModern.js Builder#\n\nRspress 底层基于 Modern.js Builder 的 Rspack 模式来进行文档构建。\n\nModern.js Builder 提供了丰富的构建配置，你可以使用 builderConfig 来自定义这些配置项。比如，将产物目录修改为 doc_dist：\n\n\n\nexport default defineConfig({\n  builderConfig: {\n    output: {\n      distPath: {\n        root: 'doc_dist',\n      },\n    },\n    tools: {\n      rspack(options) {\n        // 修改 rspack 的配置\n      },\n    },\n  },\n});\n\n\nTIP\n\n你可以通过 Modern.js Builder - API 的文档来了解更多的配置项。\n\n注意，Rspress 仅支持 Rspack 打包工具，因此一些与 webpack 相关的配置项将无法生效，比如 tools.webpack。当然，你可以通过\ntools.rspack 来修改 Rspack 的配置。\n\n\nMDX 编译插件#\n\n在框架中 MDX 的编译基于 unified 完成，你可以通过 markdown 配置来添加相关的编译插件。比如\n\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [\n      [\n        require('remark-autolink-headings'),\n        {\n          behavior: 'wrap',\n        },\n      ],\n    ],\n    rehypePlugins: [require('rehype-slug')],\n  },\n});\n","frontmatter":{}},{"id":39,"title":"自动化导航栏/侧边栏","routePath":"/zh/guide/basic/auto-nav-sidebar","lang":"zh","toc":[{"text":"基础概念","id":"基础概念","depth":2,"charIndex":192},{"text":"导航栏级别配置","id":"导航栏级别配置","depth":2,"charIndex":999},{"text":"侧边栏级别配置","id":"侧边栏级别配置","depth":2,"charIndex":1186},{"text":"string","id":"string","depth":3,"charIndex":1489},{"text":"obejct","id":"obejct","depth":3,"charIndex":1616},{"text":"完整示例","id":"完整示例","depth":3,"charIndex":2505},{"text":"无配置用法","id":"无配置用法","depth":3,"charIndex":2848},{"text":"标题前添加 svg 图标","id":"标题前添加-svg-图标","depth":3,"charIndex":3413}],"domain":"","content":"#\n\n在 Rspress 中，除了在配置文件中通过 themeConfig 声明 nav 和 sidebar， 你也可以通过声明 _meta.json\n描述文件来自动化生成导航栏和侧边栏，我们更加推荐后者，因为可以使配置文件更加简洁和清晰。\n\n提示\n\n当配置文件 rspress.config.ts 中没有 nav 和 sidebar 配置的情况下，自动化导航栏/侧边栏才会生效。\n\n\n基础概念#\n\n首先，_meta.json 可以分为两类：导航栏级别和侧边栏级别。两者的区别在于，导航级别的 _meta.json 位于文档根目录中，而侧边栏级别的\n_meta.json 位于文档根目录的子目录中。比如:\n\ndocs\n├── _meta.json // 导航栏级别\n└── guides\n    ├── _meta.json // 侧边栏级别\n    ├── introduction.mdx\n    └── advanced\n        ├── _meta.json // 侧边栏级别\n        └── plugin-development.md\n\n\n如果你的文档使用了国际化，那么导航栏级别的 _meta.json 会放置在对应语言目录下，比如：\n\ndocs\n├── en\n│   ├── _meta.json // 导航栏级别\n│   └── guides\n│       ├── _meta.json // 侧边栏级别\n│       ├── introduction.mdx\n│       ├── install.mdx\n│       └── advanced\n│           ├── _meta.json // 侧边栏级别\n│           └── plugin-development.md\n└── zh\n    ├── _meta.json // 导航栏级别\n    └── guides\n        ├── _meta.json // 侧边栏级别\n        ├── introduction.mdx\n        ├── install.mdx\n        └── advanced\n            ├── _meta.json // 侧边栏级别\n            └── plugin-development.md\n\n\n\n导航栏级别配置#\n\n在导航栏级别的情况中，你可以在 _meta.json 中填入一个数组，其类型跟默认主题的 nav 配置完全一致，详情可以参考nav 配置。比如:\n\n[\n  {\n    \"text\": \"Guide\",\n    \"link\": \"/guides/introduction\",\n    \"activeMatch\": \"^/guides/\"\n  }\n]\n\n\n\n侧边栏级别配置#\n\n在侧边栏级别的情况中，你可以在 _meta.json 中填入一个数组，数组每一项的类型如下:\n\nexport type SideMetaItem =\n  | string\n  | {\n      type: 'file';\n      name: string;\n      label?: string;\n    }\n  | {\n      type: 'dir';\n      name: string;\n      label?: string;\n      collapsible?: boolean;\n      collapsed?: boolean;\n    };\n\n\n\nstring#\n\n当类型为 string 时，表示该项是一个文件，文件名为该字符串，比如:\n\n[\"introduction\"]\n\n\n其中文件名可以带后缀，也可以不带后缀，比如 introduction 会被解析为 introduction.mdx。\n\n\nobejct#\n\n当类型为对象形式时，你可以描述为一个文件、目录或者自定义链接。\n\n在描述文件的情况下，类型如下:\n\n{\n  type: 'file';\n  name: string;\n  label?: string;\n}\n\n\n其中，name 表示文件名，同时支持带/不带后缀，label 表示该文件在侧边栏中的显示名称，为可选值，如果未填则会自动取文档中的 h1 标题。比如:\n\n{\n  \"type\": \"file\",\n  \"name\": \"introduction\",\n  \"label\": \"Introduction\"\n}\n\n\n在描述目录的情况下，类型如下:\n\n{\n  type: 'dir';\n  name: string;\n  label: string;\n  collapsible?: boolean;\n  collapsed?: boolean;\n}\n\n\n其中，name 表示目录名，label 表示该目录在侧边栏中的显示名称，collapsible 表示该目录是否可以折叠，collapsed\n表示该目录是否默认折叠，比如:\n\n{\n  \"type\": \"dir\",\n  \"name\": \"advanced\",\n  \"label\": \"Advanced\",\n  \"collapsible\": true,\n  \"collapsed\": false\n}\n\n\n在描述自定义链接的情况下，类型如下:\n\n{\n  type: 'custom-link';\n  label: string;\n  link: string;\n}\n\n\n其中，label 表示该链接在侧边栏中的显示名称，link 表示该链接的跳转地址，比如:\n\n{\n  \"type\": \"custom-link\",\n  \"label\": \"My Link\",\n  \"link\": \"/my-link\"\n}\n\n\nlink 支持外部链接，比如:\n\n{\n  \"type\": \"custom-link\",\n  \"link\": \"https://github.com\",\n  \"label\": \"GitHub\"\n}\n\n\n\n完整示例#\n\n下面是一个完整的示例，用到了上述的三种类型:\n\n[\n  \"install\",\n  {\n    \"type\": \"file\",\n    \"name\": \"introduction\",\n    \"label\": \"Introduction\"\n  },\n  {\n    \"type\": \"dir\",\n    \"name\": \"advanced\",\n    \"label\": \"Advanced\",\n    \"collapsible\": true,\n    \"collapsed\": false\n  },\n  {\n    \"type\": \"custom-link\",\n    \"label\": \"My Link\",\n    \"link\": \"/my-link\"\n  }\n]\n\n\n\n无配置用法#\n\n某些目录下你可以不配置\n_meta.json，让框架自动帮你生成侧边栏。这需要保证目录下仅包含文档，而不包含子目录，并且你对文档的顺序没有要求。比如现在有如下的文档结构:\n\ndocs\n├── _meta.json\n└── guides\n  ├── _meta.json\n  └── basic\n    ├── introduction.mdx\n    ├── install.mdx\n    └── plugin-development.md\n\n\n在 guides 目录中你可以配置 _meta.json 内容如下:\n\n[\n  {\n    \"type\": \"dir\",\n    \"name\": \"basic\",\n    \"label\": \"Basic\",\n    \"collapsible\": true,\n    \"collapsed\": false\n  }\n]\n\n\n而在 basic 目录中，你可以不配置\n_meta.json，框架会自动帮你生成侧边栏，默认按照文件名的字母顺序排序。如果你想要自定义顺序，可以在文件名前加上数字前缀，比如:\n\nbasic\n  ├── 1-introduction.mdx\n  ├── 2-install.mdx\n  └── 3-plugin-development.md\n\n\n\n标题前添加 svg 图标#\n\n此外，你还可以通过 tag 配置在标题前添加图标，比如:\n\n{\n  \"type\": \"file\",\n  \"name\": \"introduction\",\n  \"label\": \"Introduction\",\n  \"tag\": \"\"\n}\n\n\ntag 的值为 svg 标签字符串或者图片 URL，你可以将其配置到导航栏或者侧边栏中。","frontmatter":{}},{"id":40,"title":"约定式路由","routePath":"/zh/guide/basic/conventional-route","lang":"zh","toc":[{"text":"什么是约定式路由","id":"什么是约定式路由","depth":2,"charIndex":3},{"text":"映射规则","id":"映射规则","depth":2,"charIndex":122},{"text":"组件路由","id":"组件路由","depth":2,"charIndex":393},{"text":"自定义行为","id":"自定义行为","depth":2,"charIndex":677},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":990}],"domain":"","content":"#\n\n\n什么是约定式路由#\n\nRspress 使用的是文件系统路由，页面的文件路径会简单的映射为路由路径，这样会让整个项目的路由非常直观。\n\n例如，如果在 docs 目录中有一个名为 foo.md 的文件，则该文件的路由路径将是 /foo。\n\n\n映射规则#\n\nRspress 会自动扫描根目录和所有子目录，并将文件路径映射到路由路径。例如，如果你有以下的文件结构：\n\ndocs\n├── foo\n│   └── bar.md\n└── foo.md\n\n\n那么 bar.md 的路由路径会是 /foo/bar，foo.md 的路由路径会是 /foo。\n\n具体映射规则如下：\n\n文件路径            路由路径\nindex.md        /\n/foo.md         /foo\n/foo/bar.md     /foo/bar\n/zoo/index.md   /zoo/\n\n\n组件路由#\n\n在约定式路由中，除了.md(x)文件，还可以使用 .tsx 文件作为路由组件，在 .tsx 中默认导出一个组件，该组件会被自动注册到路由中。例如：\n\nexport default () => {\n  return \nfoo;\n};\n\n\n当然，如果你想要定制布局，可以添加一个导出，声明布局类型，例如：\n\nexport const frontmatter = {\n  // 声明布局类型\n  // 这里的 custom 布局中不会出现侧边栏\n  pageType: 'custom',\n};\n\n\n各个 pageType 的含义详情请参考API 文档。\n\n\n自定义行为#\n\n如果要自定义路由行为，可以使用配置文件中的 route 字段。例如：\n\n\n\nexport default defineConfig({\n  route: {\n    // These files will be excluded from the routing (support glob pattern)\n    exclude: ['component/**/*']\n    // These files will be included in the routing (support glob pattern)\n    include: ['other-dir/**/*'],\n  }\n});\n\n\n\n最佳实践#\n\n我们推荐你将文档文件放在 docs 目录下，这样可以让你的项目更加清晰。而对于非文档内容，比如自定义组件、工具函数等，可以放到 docs\n目录之外进行维护。比如：\n\ndocs\n└── foo.mdx\nsrc\n├── components\n│   └── CustomComponent.tsx\n└── utils\n    └── utils.ts\n","frontmatter":{}},{"id":41,"title":"自定义全局样式","routePath":"/zh/guide/basic/global-styles","lang":"zh","toc":[{"text":"使用方法","id":"使用方法","depth":2,"charIndex":68}],"domain":"","content":"#\n\n某些场景下，你可能需要在主题 UI 的基础上添加一些全局样式，框架提供了一个配置项 globalStyles 来实现这个功能。\n\n\n使用方法#\n\n在 rspress.config.ts 中添加以下配置：\n\n\n\n\nexport default defineConfig({\n  globalStyles: path.join(__dirname, 'styles/index.css'),\n});\n\n\n然后可以添加以下代码：\n\n/* styles/index.css */\n:root {\n  --modern-c-brand: #f00;\n}\n\n\n这样框架会自动搜集所有的全局样式并合并到最终的样式文件中。\n\n下面列举一些常用的全局样式：\n\n/* styles/index.css */\n\n:root {\n  /* 修改主题色 */\n  --modern-c-brand: #f00;\n  --modern-c-brand-dark: #ffa500;\n  --modern-c-brand-darker: #c26c1d;\n  --modern-c-brand-light: #f2a65a;\n  --modern-c-brand-lighter: #f2a65a;\n  /* 修改左侧侧边栏宽度 */\n  --modern-sidebar-width: 280px;\n  /* 修改右侧大纲栏宽度 */\n  --modern-aside-width: 256px;\n  /* 修改代码块标题背景 */\n  --modern-code-title-bg: rgba(250, 192, 61, 0.15);\n  /* 修改代码块内容背景 */\n  --modern-code-block-bg: rgba(214, 188, 70, 0.05);\n}\n\n\n> 如果想了解更多内部的全局样式，可以查看vars.css。","frontmatter":{}},{"id":42,"title":"静态资源处理","routePath":"/zh/guide/basic/static-assets","lang":"zh","toc":[],"domain":"","content":"#\n\n你可以在 markdown（或 mdx）文件中导入静态资源。相对路径和绝对路径都是支持的，例如，如果在 markdown\n同级目录有一张图片，你可以像这样引用它：\n\n![](./demo.png)\n\n\n当然，在 .mdx 文件中你也可以直接使用 img 标签：\n\n\n\n\nRspress 将会根据 .mdx 文件路径和图片路径，自动找到图片并响应给浏览器。\n\n另一方面，也可以使用绝对路径导入静态资源。这样，Rspress 将会在项目根目录下的 public 文件夹中寻找资源。\n\n> 项目根目录，即 rspress.config.ts 中 root 字段指定的目录。\n\n\n\nexport default defineConfig({\n  root: path.join(__dirname, 'docs'),\n});\n\n\n例如，如果根目录是 docs 并且目录结构如下\n\ndocs\n├── public\n│   └── demo.png\n├── index.mdx\n\n\n在如上的 index.mdx 文件中，你可以像这样引用 demo.png：\n\n![](./public/demo.png)\n\n\n或者用绝对路径来引用：\n\n![](/demo.png)\n","frontmatter":{}},{"id":43,"title":"使用 MDX","routePath":"/zh/guide/basic/use-mdx","lang":"zh","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":36},{"text":"使用组件","id":"使用组件","depth":2,"charIndex":115},{"text":"Front Matter","id":"front-matter","depth":2,"charIndex":218},{"text":"自定义容器","id":"自定义容器","depth":2,"charIndex":516},{"text":"代码块","id":"代码块","depth":2,"charIndex":946},{"text":"基本使用","id":"基本使用","depth":3,"charIndex":953},{"text":"代码行高亮","id":"代码行高亮","depth":3,"charIndex":1160},{"text":"显示代码行号","id":"显示代码行号","depth":3,"charIndex":1652},{"text":"开启 Rust 版本编译器","id":"开启-rust-版本编译器","depth":2,"charIndex":1784}],"domain":"","content":"#\n\nRspress 支持 MDX，这是一种功能强大的内容开发方式。\n\n\nMarkdown#\n\nMDX 是 Markdown 的超集，这意味着你可以像往常一样编写 Markdown 文件。例如：\n\n# Hello World\n\n\n\n使用组件#\n\n当你想在 Markdown 文件中使用 React 组件时，你应该使用 .mdx 扩展名来命名你的文件。例如：\n\n// docs/index.mdx\n\n\n# Hello World\n\n\n\n\n\nFront Matter#\n\n你可以在 Markdown 文件的开头添加 Front Matter，它是一个 YAML 格式的对象，用于定义一些元数据。例如：\n\n---\ntitle: Hello World\n---\n\n\n> 注意：默认情况下，Rspress 使用 h1 标题作为 html 的标题。\n\n你还可以在正文中访问 Front Mattter 中定义的属性，例如：\n\n---\ntitle: Hello World\n---\n\n# {frontmatter.title}\n\n\n前面定义的属性将作为 frontmatter 属性传递给组件。所以最终输出将是：\n\n\nHello World\n\n\n\n自定义容器#\n\n你可以使用 ::: 语法来创建自定义容器，且支持自定义标题。例如：\n\n输入：\n\n:::tip\n这是一个`tip`类型的`block`\n:::\n\n:::info\n这是一个`info`类型的`block`\n:::\n\n:::warning\n这是一个`warning`类型的`block`\n:::\n\n:::danger\n这是一个`danger`类型的`block`\n:::\n\n:::tip 自定义标题\n自定义标题的 `block`\n:::\n\n:::tip{title=自定义标题}\n自定义标题的 `block`\n:::\n\n\n输出：\n\nTIP\n\n这是一个 tip 类型的 block\n\nINFO\n\n这是一个 info 类型的 block\n\nWARNING\n\n这是一个 warning 类型的 block\n\nDANGER\n\n这是一个 danger 类型的 block\n\n自定义标题\n\n自定义标题的 block\n\n自定义标题\n\n自定义标题的 block\n\n\n代码块#\n\n\n基本使用#\n\n你可以使用 ``` 语法来创建代码块，且支持自定义标题。例如：\n\n输入:\n\n```js\nconsole.log('Hello World');\n```\n\n```js title=\"hello.js\"\nconsole.log('Hello World');\n```\n\n\n输出:\n\nconsole.log('Hello World');\n\n\nconsole.log('Hello World');\n\n\n\n代码行高亮#\n\n你可以通过如下的语法指定代码行高亮，比如:\n\n输入:\n\n```js {1,3-5}\nconsole.log('Hello World');\n\nconst a = 1;\nconsole.log(a);\nconst b = 2;\nconsole.log(b);\n```\n\n\n输出:\n\nconsole.log('Hello World');\n\nconst a = 1;\nconsole.log(a);\nconst b = 2;\nconsole.log(b);\n\n\n你也可以同时应用代码行高亮和代码块标题，比如:\n\n输入:\n\n```js title=\"hello.js\" {1,3-5}\nconsole.log('Hello World');\n\nconst a = 1;\n\nconsole.log(a);\n\nconst b = 2;\n\nconsole.log(b);\n```\n\n\n输出:\n\nconsole.log('Hello World');\n\nconst a = 1;\n\nconsole.log(a);\n\nconst b = 2;\n\nconsole.log(b);\n\n\n\n显示代码行号#\n\n如果你想要显示代码行号，你可以在配置文件中开启 showLineNumbers 选项:\n\nexport default {\n  // ...\n  markdown: {\n    showLineNumbers: true,\n  },\n};\n\n\n\n开启 Rust 版本编译器#\n\n你可以通过如下的配置开启 Rust 版本的 MDX 编译器:\n\n\n\nexport default defineConfig({\n  markdown: {\n    experimentalMdxRs: true,\n  },\n});\n\n\n注意\n\n这个功能底层基于 Rspress 自研的 @modern-js/mdx-rs-binding 库来实现，性能比 JS 版本的 MDX 编译器高 5 ~ 10\n倍，但目前还不支持 JS 版本的插件，如果你需要加入自定义的 remark 或 rehype 插件，建议不要开启这个功能。","frontmatter":{}},{"id":44,"title":"内置组件","routePath":"/zh/guide/default-theme/components","lang":"zh","toc":[{"text":"NoSSR","id":"nossr","depth":2,"charIndex":3},{"text":"Tab/Tabs","id":"tabtabs","depth":2,"charIndex":118}],"domain":"","content":"#\n\n\nNoSSR#\n\n用于在服务端渲染时不渲染某些组件。使用方法如下：\n\n\n\nconst Component = () => {\n  return (\n    \n      \n这里的内容只会在客户端渲染\n    \n  );\n};\n\n\n\nTab/Tabs#\n\n你可以在文档中直接使用 Tab/Tabs 组件来实现 tab 切换的效果。比如\n\n\n\nfunction App() {\n  return (\n    \n      Tab 1 content\n      Tab 2 content\n    \n  );\n}\n\n\n提醒\n\n为了让你更方便地使用这些组件，框架内部对于 rspress/theme 这个包做了 alias 处理，所以你可以直接使用 @theme 来引入这些组件。\n\n其中 Tabs 组件的 props 类型如下:\n\ninterface TabsProps {\n  children: React.ReactNode;\n  defaultValue?: string;\n  groupId?: string;\n}\n\n\ndefaultValue 用于设置默认选中的 tab 项，这个值会和 Tab 组件的 value 字段做比较，如果相等则选中该 tab。\n\ngroupId 用于设置 tab 项的分组，当你需要多个 Tabs 组件进行联动的时候，可以通过 groupId 来实现。groupId 相同的 Tabs\n组件会进行联动。\n\nTab 组件的 props 类型如下:\n\ninterface TabProps {\n  label: string;\n  // 用于标识当前 tab，如果不传则默认使用 label\n  value?: string;\n  children: React.ReactNode;\n}\n\n\n其中的 value 字段用于标识当前 tab，如果不传则默认使用 label。","frontmatter":{}},{"id":45,"title":"正文页面","routePath":"/zh/guide/default-theme/doc-page","lang":"zh","toc":[{"text":"页面类型","id":"页面类型","depth":2,"charIndex":3},{"text":"侧边栏","id":"侧边栏","depth":2,"charIndex":166},{"text":"大纲栏标题","id":"大纲栏标题","depth":2,"charIndex":225},{"text":"上一页/下一页文本","id":"上一页下一页文本","depth":2,"charIndex":353}],"domain":"","content":"#\n\n\n页面类型#\n\n你可以在 frontmatter 元数据中指定 pageType，以便在页面中使用不同的布局。默认情况下，文档的 pageType 是\ndoc，这样会默认出现左边的侧边栏和右侧的大纲栏。如果你不需要这些，可以将 pageType 设置为 custom:\n\n---\npageType: custom\n---\n\n\n\n侧边栏#\n\n在 rspress.config.ts 中，你可以配置侧边栏的内容，具体可参考 API-侧边栏配置。\n\n\n大纲栏标题#\n\n通过 outlineTitle 配置项，你可以设置大纲栏的标题。\n\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    outlineTitle: '目录',\n  },\n});\n\n\n\n上一页/下一页文本#\n\n通过 prevText 和 nextText 配置项，你可以设置上一页/下一页的文本。\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    prevPageText: '上一页',\n    nextPageText: '下一页',\n  },\n});\n","frontmatter":{}},{"id":46,"title":"Home 主页","routePath":"/zh/guide/default-theme/home-page","lang":"zh","toc":[],"domain":"","content":"#\n\n你可以通过 frontmatter 来定义 Home 页面的内容，详细类型可见FrontMatter 配置。下面是一个简单的例子：\n\n---\npageType: home\n\nhero:\n  name: Rspress\n  text: 文档工程解决方案\n  tagline: 现代化文档开发技术栈\n  actions:\n    - theme: brand\n      text: 介绍\n      link: /zh/guide/introduction\n    - theme: alt\n      text: 快速开始\n      link: /zh/guide/getting-started\n\nfeatures:\n  - title: 'MDX: 使用灵活语法编写内容'\n    details: MDX 是一种强大的内容编写方式，你可以在 Markdown 中使用 React 组件。\n    icon: 📦\n  - title: '功能丰富: 一站式解决方案'\n    details: 对全文搜索、国际化等常见功能可以做到开箱即用。\n    icon: 🎨\n  - title: '扩展性强: 提供多种自定义能力'\n    details: 通过其扩展机制，你可以轻松的扩展主题 UI 和构建能力。\n    icon: 🚀\n---\n","frontmatter":{}},{"id":47,"title":"国际化","routePath":"/zh/guide/default-theme/i18n","lang":"zh","toc":[{"text":"定义 I18n 文本数据","id":"定义-i18n-文本数据","depth":2,"charIndex":171},{"text":"配置默认语言","id":"配置默认语言","depth":2,"charIndex":674},{"text":"配置 locales 数据","id":"配置-locales-数据","depth":2,"charIndex":875},{"text":"新建不同的语言版本的文档","id":"新建不同的语言版本的文档","depth":2,"charIndex":1665},{"text":"配置侧边栏和导航栏","id":"配置侧边栏和导航栏","depth":2,"charIndex":2027},{"text":"自定义组件中使用 useI18n","id":"自定义组件中使用-usei18n","depth":2,"charIndex":3005}],"domain":"","content":"#\n\n在 Rspress 中实现文档的国际化，你需要做如下的操作:\n\n * 1. 定义 I18n 文本数据。\n * 2. 配置默认语言。\n * 3. 配置 locales 和 themeConfig.locales。\n * 4. 新建不同的语言版本的文档。\n * 5. 配置侧边栏和导航栏。\n * 6. 自定义组件中使用 useI18n。\n\n\n定义 I18n 文本数据#\n\n在当前工作区新建 i18n.json，目录结构如下：\n\n.\n├── docs\n├── i18n.json\n├── package.json\n├── tsconfig.json\n└── rspress.config.ts\n\n\n在这个 JSON 文件中，你可以定义国际化所需的文本，类型定义如下:\n\nexport interface I18n {\n  // key 为文本 id\n  [key: string]: {\n    // key 为语言\n    [key: string]: string;\n  };\n}\n\n\n举个例子:\n\n{\n  \"getting-started\": {\n    \"zh\": \"开始\",\n    \"en\": \"Getting Started\"\n  },\n  \"features\": {\n    \"zh\": \"基础功能\",\n    \"en\": \"Features\"\n  },\n  \"guide\": {\n    \"zh\": \"指南\",\n    \"en\": \"Guide\"\n  }\n}\n\n\n这些文本数据在配置文件和自定义组件中都会用到，后文会详细介绍。\n\n\n配置默认语言#\n\n在 rspress.config.ts中，你可以通过 lang 配置文档的默认语言，如下例子所示:\n\n\n\nexport default defineConfig({\n  lang: 'zh',\n});\n\n\n这很重要，因为对于默认语言下的路由，框架会去掉语言前缀，比如 /zh/guide/getting-started 会被转换为\n/guide/getting-started。\n\n\n配置 locales 数据#\n\n在 rspress.config.ts中，你可以通过两个地方来配置 locales 数据:\n\n * locales，用于配置站点的语言、标题、描述等信息，主要围绕站点本身的信息来配置。\n * themeConfig.locales，用于配置主题的语言、大纲栏标题、上一页/下一页文本等信息，主要进行主题相关的配置。\n\n\n\nexport default defineConfig({\n  // locales 为一个对象数组\n  locales: [\n    {\n      lang: 'en',\n      // 导航栏切换语言的标签\n      label: 'English',\n      title: 'Modern.js',\n      description: 'Modern.js 文档框架',\n    },\n    {\n      lang: 'zh',\n      // 导航栏切换语言的标签\n      label: '简体中文',\n      title: 'Modern.js',\n      description: 'Rspress',\n    },\n  ],\n  themeConfig: {\n    locales: [\n      {\n        lang: 'en',\n        outlineTitle: 'ON THIS Page',\n      },\n      {\n        lang: 'zh',\n        outlineTitle: '大纲',\n      },\n    ],\n  },\n});\n\n\n注意\n\n默认主题中， themeConfig.locales 也包含 locales 中的所有字段，前者优先级更高。\n\n对于其它的国际化主题参数配置，请参考API 类型。\n\n\n新建不同的语言版本的文档#\n\n在做好上面的配置后，我们就可以开始新建不同语言版本的文档了，非常简单，我们只需要在文档根目录下新建如下的结构即可：\n\ndocs\n├── en\n│   ├── api\n│   │   └── index.md\n│   └── guide\n│       └── getting-started.md\n│       └── features.md\n└── zh\n    ├── api\n    │   └── index.md\n    └── guide\n        └── getting-started.md\n        └── features.md\n\n\n可以看到，我们把不同语言的文档放在了 docs 目录下的 en 和 zh 目录中，这样就可以方便地区分不同语言的文档了。\n\n\n配置侧边栏和导航栏#\n\n> 如果你使用了自动化导航栏/侧边栏写法，可以跳过这个部分。\n\n我们在约定式路由中提到过，针对不同的文件路径，我们会自动生成对应的路由。那么，在国际化文档的场景中，每份文档的路由是不一样的，那么针对 N\n种语言的文档，我们需要写 N 份侧边栏和导航栏的配置吗？\n\n答案是不用。在 Rspress 框架中，你只需要写一份配置即可。如何完成呢？\n\n我们来这样配置侧边栏和导航栏:\n\n\n\n// 工具函数，用于获取类型提示\nconst getI18nKey = (key: keyof typeof import('./i18n.json')) => key;\n\nexport default defineConfig({\n  // 前面的配置省略\n  themeConfig: {\n    nav: [\n      {\n        text: getI18nKey('guide'),\n        link: '/guide/',\n      },\n    ],\n    sidebar: {\n      '/guide/': [\n        {\n          text: getI18nKey('getting-started'),\n          link: '/guide/getting-started',\n        },\n        {\n          text: getI18nKey('features'),\n          link: '/guide/features',\n        },\n      ],\n    },\n  },\n});\n\n\n可以看到，在 nav 和 sidebar 的配置中，我们主要涉及到两种元素的配置:\n\n * 文本。在国际化场景中，你只需要传入 i18n.json 中的文案 key 即可，框架会自动根据当前语言来获取对应的文本。\n * 链接。你无需添加语言前缀，框架会自动根据当前语言来添加对应的语言前缀。比如默认语言为中文的情况下，在英文文档中 /guide/features 会被转换为\n   /en/guide/features。\n\n最后你只需要写一份 nav 和 sidebar 的配置，框架会自动根据当前语言来获取对应的文本和链接。\n\n\n自定义组件中使用 useI18n#\n\n在 MDX 开发或者自定义主题开发的过程中，你可能会写一些自定义组件，这些组件中也需要使用到国际化文本，那么如何获取呢？\n\n框架提供了 useI18n 这个 hook 来获取国际化文本，使用方式如下：\n\n\n\nconst MyComponent = () => {\n  const { t } = useI18n();\n\n  return \n{t('getting-started')};\n};\n\n\n为了获得更好的类型提示，你可以在 tsconfig.json 中配置 paths:\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"i18n\": [\"./i18n.json\"]\n    }\n  }\n}\n\n\n然后在组件中这样使用:\n\n\n\nconst MyComponent = () => {\n  const { t } = useI18n();\n\n  return \n{t('getting-started')};\n};\n\n\n这样你就可以获得 i18n.json 中定义的所有文本 key 的类型提示了。","frontmatter":{}},{"id":48,"title":"导航栏模块","routePath":"/zh/guide/default-theme/navbar","lang":"zh","toc":[{"text":"自定义导航菜单","id":"自定义导航菜单","depth":2,"charIndex":65},{"text":"NavItemWithLink","id":"navitemwithlink","depth":3,"charIndex":394},{"text":"NavItemWithChildren","id":"navitemwithchildren","depth":3,"charIndex":874},{"text":"示例","id":"示例","depth":3,"charIndex":1116},{"text":"白天/夜间模式","id":"白天夜间模式","depth":2,"charIndex":1893},{"text":"相关链接","id":"相关链接","depth":2,"charIndex":2026}],"domain":"","content":"#\n\n导航栏对一个网站来说非常重要，它可以让用户快速的在网站的不同页面之间进行跳转，也可以让用户快速的找到网站的一些重要信息。\n\n\n自定义导航菜单#\n\n你可以在 themeConfig.nav 中添加自定义的导航菜单，配置为一个数组，如下：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    nav: [],\n  },\n});\n\n\n导航栏配置为一个数组，数组中的每一项都是一个 NavItem 对象，它具有以下类型：\n\nexport type NavItem = NavItemWithLink | NavItemWithChildren;\n\n\n也就是说，每个导航栏元素( NavItem )可以是一个链接( NavItemWithLink )，也可以是一个包含子元素的导航栏组(\nNavItemWithChildren )。\n\n\nNavItemWithLink#\n\nexport interface NavItemWithLink {\n  text: string;\n  link: string;\n  activeMatch?: string;\n  position?: 'left' | 'right';\n}\n\n\n其中各项属性的含义如下:\n\n * text - 导航栏文本\n * link - 导航栏链接\n * activeMatch - 导航栏链接的激活规则\n * position - 导航栏菜单项定位\n\n属性详情：\n\nactiveMatch 用于匹配当前路由，当路由匹配 activeMatch 规则时，nav 项会高亮显示。\n\n> 默认情况下，activeMatch 是 NavItem 的 link 属性。\n\nposition 用于配置顶部菜单项的独立定位，可选项为：\n\n * 'left'：置于菜单项到顶部的左侧菜单栏；\n * 'right'：置于菜单项到顶部的右侧菜单栏。\n\n> 如果position未配置的情况下会默认放到右侧菜单栏，效果等同于配置'right'。\n\n\nNavItemWithChildren#\n\nexport interface NavItemWithChildren {\n  text: string;\n  items: (NavItemWithLink | NavItemWithChildren)[];\n  position?: 'left' | 'right';\n}\n\n\n其中各项属性的含义如下:\n\n * text - 导航栏文本\n * items - 子导航栏元素\n * position- 带有子元素的导航栏菜单项定位\n\n\n示例#\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    nav: [\n      {\n        text: 'Home',\n        link: '/',\n        position: 'left',\n      },\n      {\n        text: '更多链接',\n        items: [\n          {\n            text: 'Github',\n            link: 'http://github.com/',\n          },\n          {\n            text: 'Twitter',\n            link: 'http://twitter.com/',\n          },\n          // 也可以是一个导航栏组\n          {\n            text: 'Group',\n            items: [\n              {\n                text: 'Personal',\n                link: 'http://xxx.com/',\n              },\n              {\n                text: 'Company',\n                link: 'http://xxx.com/',\n              },\n            ],\n          },\n        ],\n        position: 'right',\n      },\n    ],\n  },\n});\n\n\n\n白天/夜间模式#\n\n默认情况下导航栏会带上 白天/夜间 模式的切换按钮，你可以通过如下的配置禁用：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    darkMode: false,\n  },\n});\n\n\n\n相关链接#\n\n网站的社交链接。比如：\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    socialLinks: [\n      {\n        icon: 'github',\n        link: 'github.com/web-infra-dev/modern.js',\n      },\n    ],\n  },\n});\n\n\n更多配置请参考 链接。","frontmatter":{}},{"id":49,"title":"预览页","routePath":"/zh/guide/default-theme/overview-page","lang":"zh","toc":[{"text":"效果","id":"效果","depth":2,"charIndex":3},{"text":"如何开启？","id":"如何开启","depth":2,"charIndex":32},{"text":"1. 新建目录，配置 frontmatter","id":"1-新建目录配置-frontmatter","depth":3,"charIndex":55},{"text":"2. 配置 sidebar","id":"2-配置-sidebar","depth":3,"charIndex":264}],"domain":"","content":"#\n\n\n效果#\n\nRspress 内置一套预览页，效果如下:\n\n\n如何开启？#\n\n生成预览页需要如下两步:\n\n\n1. 新建目录，配置 frontmatter#\n\n比如新建如下的目录和文件:\n\n├── docs\n│   ├── index.md\n│   ├── api\n│   │   ├── index.md\n│   │   ├── preview1.md\n│   │   └── preview2.md\n// ...\n\n\n我们在 api/index.md 中添加如下内容:\n\n---\noverview: true\n---\n\n\n\n2. 配置 sidebar#\n\n配置预览页面的结构会基于 sidebar 的配置来生成，比如我们添加如下的 sidebar 配置:\n\n\n\nexport default defineConfig({\n  themeConfig: {\n    sidebar: {\n      '/api/': [\n        {\n          text: 'Group1',\n          items: [\n            // 注意: 需要提前创建好文档\n            '/api/foo',\n            '/api/bar',\n          ],\n        },\n        {\n          text: 'Group2',\n          items: ['/api/xxx', '/api/yyy'],\n        },\n      ],\n    },\n  },\n});\n\n\n框架会摘取所有 api 目录下的文件以及其中的 h1、h2 标题，并根据 sidebar 配置中的分组信息生成预览页。","frontmatter":{}},{"id":50,"title":"快速开始","routePath":"/zh/guide/start/getting-started","lang":"zh","toc":[{"text":"1. 初始化项目","id":"1-初始化项目","depth":2,"charIndex":3},{"text":"方式一：通过脚手架创建","id":"方式一通过脚手架创建","depth":3,"charIndex":15},{"text":"方式二：手动创建","id":"方式二手动创建","depth":3,"charIndex":168},{"text":"2. 启动 Dev Server","id":"2-启动-dev-server","depth":2,"charIndex":725},{"text":"3. 生产环境构建","id":"3-生产环境构建","depth":2,"charIndex":797},{"text":"4. 本地预览产物","id":"4-本地预览产物","depth":2,"charIndex":882}],"domain":"","content":"#\n\n\n1. 初始化项目#\n\n\n方式一：通过脚手架创建#\n\n你可以通过 Modern.js 脚手架命令来创建一个 Rspress 项目:\n\n# `modern-doc-app` 为项目名称\nnpx @modern-js/create@latest rspress-app\n\n\n选择 文档站 类型，然后选择包管理工具即可完成项目创建。\n\n\n方式二：手动创建#\n\n首先，你可以通过以下命令创建一个新目录：\n\nmkdir rspress-app && cd rspress-app\n\n\n执行 npm init -y 来初始化一个项目。你可以使用 npm、yarn 或 pnpm 安装 Rspress:\n\n然后通过如下命令创建文件:\n\nmkdir docs && echo '# Hello World' > docs/index.md\n\n\n在package.json中加上如下的脚本:\n\n{\n  \"scripts\": {\n    \"dev\": \"rspress dev\",\n    \"build\": \"rspress build\",\n    \"preview\": \"rspress preview\"\n  }\n}\n\n\n然后初始化一个配置文件 rspress.config.ts:\n\n\n\n\nexport default defineConfig({\n  root: path.join(__dirname, 'docs'),\n});\n\n\n同时新建 tsconfig.json，内容如下:\n\n{\n  \"compilerOptions\": {\n    \"esModuleInterop\": true,\n    \"jsx\": \"react-jsx\"\n  }\n}\n\n\n\n2. 启动 Dev Server#\n\n通过如下命令启动本地开发服务:\n\nnpm run dev\n\n\n这样 Rspress 将启动开发服务。\n\n\n3. 生产环境构建#\n\n通过如下命令构建生产环境的产物:\n\nnpm run build\n\n\n默认情况下，Rspress 将会把产物打包到 doc_build 目录。\n\n\n4. 本地预览产物#\n\n通过如下命令启动本地预览服务:\n\nnpm run preview\n\n\n这样 Rspress 将启动产物预览服务。","frontmatter":{}},{"id":51,"title":"介绍","routePath":"/zh/guide/start/introduction","lang":"zh","toc":[{"text":"定位","id":"定位","depth":2,"charIndex":3},{"text":"功能特性","id":"功能特性","depth":2,"charIndex":221},{"text":"支持 MDX 渲染","id":"支持-mdx-渲染","depth":3,"charIndex":229},{"text":"支持全文搜索","id":"支持全文搜索","depth":3,"charIndex":358},{"text":"支持国际化(I18n)","id":"支持国际化i18n","depth":3,"charIndex":405},{"text":"代码块高亮","id":"代码块高亮","depth":3,"charIndex":458},{"text":"自动生成布局","id":"自动生成布局","depth":3,"charIndex":581},{"text":"支持自定义主题","id":"支持自定义主题","depth":3,"charIndex":697},{"text":"支持插件机制","id":"支持插件机制","depth":3,"charIndex":747}],"domain":"","content":"#\n\n\n定位#\n\nRspress 是一个面向文档站场景的前端框架，它的目标是给开发者提供一个简单、高效、可扩展的文档站解决方案。\n\n该文档框架的初衷是给公司内部的技术产品提供文档站搭建的解决方案，并满足内部的一些特殊需求，如跨站点搜索服务等。而对于常见的文档站搭建需求，我们也做了比较完整的支\n持，比如支持多语言、全文搜索、自定义主题等等。\n\n同时，框架基于 Rspack 来进行项目构建，性能优秀，让你在数秒内就能启动和构建一个文档站。\n\n\n功能特性#\n\n\n支持 MDX 渲染#\n\nRspress 基于 MDX 来进行 Markdown 语法的扩展，支持在 Markdown 中使用 React 组件，同时支持在 Markdown 中使用\nJSX 语法，语法上更加灵活。\n\n语法详情请参考 使用 MDX 小节。\n\n\n支持全文搜索#\n\n基于开源 FlexSearch 搜索引擎，提供开箱即用的文档搜索能力。\n\n\n支持国际化(I18n)#\n\n内置国际化支持，支持多语言切换，且支持多语言内容搜索。详情可见 国际化。\n\n\n代码块高亮#\n\n基于 PrismJS 来进行运行时代码着色，支持多种代码语言高亮。如:\n\n\n\n\nexport default defineConfig({\n  root: path.join(__dirname, 'docs'),\n});\n\n\n\n自动生成布局#\n\n内置了多种布局组件，如：顶部导航、左侧侧边栏等，你可以通过配置文件来进行自动生成，详情可参考自动化导航栏/侧边栏。\n\n同时，你也可以通过配置 pageType 来自定义布局类型，详情可参考 pageType。\n\n\n支持自定义主题#\n\n支持自定义主题，可以通过配置文件来进行主题的定制，详情请参考 自定义主题。\n\n\n支持插件机制#\n\n内部设计了插件系统，你可以通过自定义插件来扩展 Rspress 的功能，详情请参考 插件机制。","frontmatter":{}},{"id":53,"title":"总览","routePath":"/zh/plugin/official-plugins/overview","lang":"zh","toc":[],"domain":"","content":"#\n\n官方插件包括如下:\n\n * @rspress/doc-plugin-typedoc： TypeDoc 集成插件，用于自动生成 TS 模块的 API 文档。","frontmatter":{}},{"id":54,"title":"@rspress/doc-plugin-typedoc","routePath":"/zh/plugin/official-plugins/typedoc","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":50},{"text":"使用","id":"使用","depth":2,"charIndex":196},{"text":"参数说明","id":"参数说明","depth":2,"charIndex":1292},{"text":"entryPoints","id":"entrypoints","depth":3,"charIndex":1300},{"text":"outDir","id":"outdir","depth":3,"charIndex":1374}],"domain":"","content":"#\n\n集成 TypeDoc 的 Rspress 插件，用于自动生成 TS 模块的 API 文档。\n\n\n安装#\n\n# npm\nnpm install @rspress/doc-plugin-typedoc\n# yarn\nyarn add @rspress/doc-plugin-typedoc\n# pnpm\npnpm install @rspress/doc-plugin-typedoc\n\n\n\n使用#\n\n\n\n\n\nexport default defineConfig({\n  plugins: [\n    pluginTypeDoc({\n      entryPoints: [\n        path.join(__dirname, 'src', 'foo.ts'),\n        path.join(__dirname, 'src', 'bar.ts'),\n      ],\n    }),\n  ],\n});\n\n\n/**\n * 这是一个add函数\n */\nexport function add(\n  /**\n   * This is param1\n   */\n  param1: string,\n  /**\n   * This is param2\n   */\n  param2: number,\n) {\n  return 1;\n}\n\n\n/**\n * This is multi function\n */\nexport function multi(\n  /**\n   * This is param1\n   */\n  param1?: string,\n  /**\n   * This is param2\n   */\n  param2?: number,\n) {\n  return 1;\n}\n\n\n当你启动项目后，插件会在你的文档根目录下自动生成 api 目录，目录结构如下：\n\napi\n├── README.md\n├── documentation.json\n├── functions\n│   ├── bar.multi.md\n│   └── foo.add.md\n├── interfaces\n│   ├── foo.RunTestsOptions.md\n│   └── foo.TestMessage.md\n└── modules\n    ├── bar.md\n    └── foo.md\n\n\n也就是说，插件内部会调用 TypeDoc 帮你自动生成模块的 API 文档，包含模块列表、Interface 详情、函数详情(入参、返回值、描述信息)\n等信息，同时也会生成 documentation.json 文件，用于后续的侧边栏渲染。\n\n注意，每次启动项目时都会根据最新的模块内容重新生成文档。因此，我们建议将 api 目录加入 .gitignore\n中，如果你通过下面的outDir参数自定义了输出目录，也应该将其加入 .gitignore 中。\n\n同时，我们也不建议在 api 目录下修改或新增文档，因为随着模块内容的变化，这些文档在每次项目启动时会被覆盖。\n\n\n参数说明#\n\n\nentryPoints#\n\n * 类型：string[]\n * 默认值：[]\n\n指定需要生成文档的 TS 模块路径，你需要传入模块的绝对路径。\n\n\noutDir#\n\n * 类型：string\n * 默认值：api\n\n自定义文档输出目录，你需要传入一个相对路径，比如 api/custom。","frontmatter":{}},{"id":55,"title":"介绍","routePath":"/zh/plugin/system/introduction","lang":"zh","toc":[],"domain":"","content":"#\n\n插件机制是 Rspress 至关重要的部分，它可以让你在搭建站点的过程中，方便地扩展框架的功能。那么，你可以通过插件扩展哪些功能呢？我们先来看看 Rspress\n的整体架构。\n\nRspress 的整体架构如下图所示：\n\n\n\n框架整体分为Node 端和浏览器运行时两部分。通过插件机制，你可以轻松地扩展这两部分的功能。具体来说，你可以扩展如下的能力:\n\n * Markdown/MDX 编译功能。你可以通过添加 remark/rehype 插件，扩展 Markdown/MDX 的语法和功能。\n * 添加自定义页面。在框架约定式路由的基础，你也可以通过插件，添加新路由，比如添加一个 /blog 路由，用于展示博客列表，内容由你自己定义。\n * 定制构建工具的行为。在框架插件中，你可以自定义底层构建工具 Rspack 的配置，如 define、alias，也可以添加自定义 Rspack 插件。\n * 扩展页面元数据。针对每个页面，框架内部会计算出一些元数据，如 title、description\n   等等，你可以通过插件，扩展这些元数据的计算逻辑，并在运行时通过 usePageData hook 访问到。\n * 在构建流程前后插入一些自定义逻辑。如在构建流程结束后关闭一些事件监听器。\n * 添加全局组件。Rspress 内部使用 React 进行渲染，你可以通过定义全局 React 组件来灵活地扩展页面运行时的功能，比如添加全局的\n   BackToTop(返回顶部) 组件、添加全局副作用逻辑。","frontmatter":{}},{"id":56,"title":"插件 API","routePath":"/zh/plugin/system/plugin-api","lang":"zh","toc":[{"text":"globalStyles","id":"globalstyles","depth":3,"charIndex":123},{"text":"globalUIComponents","id":"globaluicomponents","depth":3,"charIndex":641},{"text":"builderConfig","id":"builderconfig","depth":3,"charIndex":1512},{"text":"config","id":"config","depth":3,"charIndex":2071},{"text":"beforeBuild/afterBuild","id":"beforebuildafterbuild","depth":3,"charIndex":2441},{"text":"markdown","id":"markdown","depth":3,"charIndex":2935},{"text":"extendPageData","id":"extendpagedata","depth":3,"charIndex":3557},{"text":"addPages","id":"addpages","depth":3,"charIndex":4054},{"text":"routeGenerated","id":"routegenerated","depth":3,"charIndex":4920}],"domain":"","content":"#\n\n上一节我们介绍了插件的基本结构，本节我们来介绍插件的 API，帮助你更细致地了解插件功能。\n\n提示\n\n为了获得更好的类型提示，你可以在项目中安装 @rspress/shared，然后通过 `` 来引入 RspressPlugin 类型。\n\n\nglobalStyles#\n\n * 类型：string\n\n用于添加全局样式，传入一个样式文件的绝对路径，使用方式如下：\n\n\n\n\nexport function pluginForDoc(): RspressPlugin {\n  // 样式路径\n  const stylePath = path.join(__dirname, 'some-style.css');\n  return {\n    // 插件名称\n    name: 'plugin-name',\n    // 全局样式的路径\n    globalStyles: path.join(__dirname, 'global.css'),\n  };\n}\n\n\n比如你想修改主题色，可以通过添加全局样式来实现：\n\n:root {\n  --modern-c-brand: #ffa500;\n  --modern-c-brand-dark: #ffa500;\n  --modern-c-brand-darker: #c26c1d;\n  --modern-c-brand-light: #f2a65a;\n  --modern-c-brand-lighter: #f2a65a;\n}\n\n\n\nglobalUIComponents#\n\n * 类型：string[]\n\n用于添加全局组件，传入一个数组，数组中的每一项都是一个组件的绝对路径，使用方式如下：\n\n\n\nexport function pluginForDoc(): RspressPlugin {\n  // 组件路径\n  const componentPath = path.join(__dirname, 'xxx.tsx');\n  return {\n    // 插件名称\n    name: 'plugin-comp',\n    // 全局组件的路径\n    globalUIComponents: [componentPath],\n  };\n}\n\n\n当你注册了全局组件之后，框架会自动将这些 React 组件在主题中进行渲染，而不用你手动引入。\n\n通过全局组件，你可以完成诸多自定义的功能，比如:\n\n\n\n// 需要默认导出一个组件\nexport default function PluginUI() {\n  return \n这是一个全局的布局组件;\n}\n\n\n这样，在主题页面中会渲染组件的内容，比如添加回到顶部按钮。\n\n同时，你也可以通过全局组件来注册全局副作用。比如：\n\n\n\n\n// 需要默认导出一个组件\nexport default function PluginSideEffect() {\n  const { pathname } = useLocation();\n  useEffect(() => {\n    // 组件初次渲染时执行\n  }, []);\n\n  useEffect(() => {\n    // 路由变化时执行\n  }, [pathname]);\n  return null;\n}\n\n\n这样，在主题页面中会执行组件的副作用。比如以下的一些需要副作用的场景:\n\n * 针对某些页面路由进行重定向操作。\n\n * 对页面的 img 标签进行事件监听，实现图片放大功能。\n\n * 路由变化时，上报不同页面的 PV 数据。\n\n * ......\n\n\nbuilderConfig#\n\n * 类型：BuilderConfig\n\nRspress 底层基于 Modern.js Builder 的 Rspack 模式来进行文档构建。通过 builderConfig 可以对 Builder\n进行配置，具体的配置项可以参考 Modern.js Builder。\n\n> 当然，如果你想要直接配置 Rspack，也可以通过 buildConfig.tools.rspack 进行配置。\n\n\n\nexport function pluginForDoc(slug: string): RspressPlugin {\n  return {\n    // 插件名称\n    name: 'plugin-name',\n    // 构建阶段的全局变量定义\n    builderConfig: {\n      source: {\n        define: {\n          SLUG: JSON.stringify(slug),\n        },\n      },\n      tools: {\n        rspack(options) {\n          // 修改 rspack 的配置\n        },\n      },\n    },\n  };\n}\n\n\n\nconfig#\n\n * 类型：(config: DocConfig) => DocConfig | Promise\n\n用于修改/扩展 Rspress 本身的配置，比如你想要修改文档的标题，可以通过 config 来实现：\n\n\n\nexport function pluginForDoc(): RspressPlugin {\n  return {\n    // 插件名称\n    name: 'plugin-name',\n    // 扩展 Rspress 本身的配置\n    config(config) {\n      return {\n        ...config,\n        // 这里可以扩展 Rspress 的配置\n        title: '新的文档标题',\n      };\n    },\n  };\n}\n\n\n\nbeforeBuild/afterBuild#\n\n * 类型：(config: DocConfig, isProd: boolean) => void | Promise\n\n用于在文档构建之前/之后执行一些操作，第一个参数是文档的配置，第二个参数是当前是否是生产环境。使用方式如下：\n\n\n\nexport function pluginForDoc(): RspressPlugin {\n  return {\n    // 插件名称\n    name: 'plugin-name',\n    // 在构建之前执行的钩子\n    async beforeBuild(config, isProd) {\n      // 这里可以执行一些操作\n    },\n    // 在构建之后执行的钩子\n    async afterBuild(config, isProd) {\n      // 这里可以执行一些操作\n    },\n  };\n}\n\n\n提醒\n\n在 beforeBuild 钩子执行时，已经经过了所有插件的 config 插件处理，因此 config 参数已经代表了最终的文档配置。\n\n\nmarkdown#\n\n * 类型：{ remarkPlugins?: Plugin[]; rehypePlugins?: Plugin[]; globalComponents?:\n   string[] }\n\n用于扩展 Markdown/MDX 的编译能力，如果你想要添加自定义的 remark/rehype 插件以及 MDX 里的全局组件，可以通过 markdown\n配置来实现：\n\n\n\nexport function pluginForDoc(): RspressPlugin {\n  return {\n    // 插件名称\n    name: 'plugin-name',\n    // 扩展 Markdown/MDX 编译能力\n    markdown: {\n      remarkPlugins: [\n        // 添加自定义的 remark 插件\n      ],\n      rehypePlugins: [\n        // 添加自定义的 rehype 插件\n      ],\n      globalComponents: [\n        // 为 MDX 注册全局组件\n      ],\n    },\n  };\n}\n\n\n注意\n\n在开启 mdx-rs 编译的情况下(即配置文件中 markdown.experimentalMdxRs 为 true)，添加的 remark/rehype\n插件会被忽略。\n\n\nextendPageData#\n\n * 类型：(pageData: PageData) => void | Promise\n\n用于扩展页面数据，比如你想要在页面数据中添加一些自定义的属性，可以通过 extendPageData 来实现：\n\n\n\nexport function pluginForDoc(): RspressPlugin {\n  return {\n    // 插件名称\n    name: 'plugin-name',\n    // 扩展页面数据\n    extendPageData(pageData) {\n      // 你可以往 pageData 对象上添加或者修改属性\n      pageData.a = 1;\n    },\n  };\n}\n\n\n在扩展页面数据之后，你可以在主题中通过 usePageData 这个 hook 来访问页面数据。\n\n\n\nexport function MyComponent() {\n  const { page } = usePageData();\n  // page.a === 1\n  return \n{page.a};\n}\n\n\n\naddPages#\n\n * 类型：(config: UserConfig) => AdditionalPage[] | Promise\n\n其中，config 为 rspress.config.ts 配置文件中导出的 doc 属性值，AdditionalPage 的类型定义如下：\n\ninterface AdditionalPage {\n  routePath: string;\n  filepath?: string;\n  content?: string;\n}\n\n\n主要用来添加额外的页面，你可以在 addPages 函数中返回一个数组，数组中的每一项都是一个页面的配置，你可以通过 routePath 来指定页面的路由，通过\nfilepath 或者 content 来指定页面的内容。比如：\n\n\n\n\nexport function docPluginDemo(): RspressPlugin {\n  return {\n    name: 'add-pages',\n    addPages(config, isProd) {\n      return [\n        //  支持真实文件的绝对路径(filepath)，这样会读取磁盘中的 md(x) 内容\n        {\n          routePath: '/filepath-route',\n          filepath: path.join(__dirname, 'blog', 'index.md'),\n        },\n        //  支持通过 content 参数直接传入 md(x) 内容\n        {\n          routePath: '/content-route',\n          content: '# Demo2',\n        },\n      ];\n    },\n  };\n}\n\n\naddPages 接受两个参数，config 为当前文档站的配置，isProd 表示是否为生产环境。\n\n\nrouteGenerated#\n\n * 类型：(routeMeta: RouteMeta[]) => void | Promise\n\n这这个钩子中，你可以拿到所有的路由信息，每一项路由信息的结构如下:\n\nexport interface RouteMeta {\n  // 路由\n  routePath: string;\n  // 文件绝对路径\n  absolutePath: string;\n  // 页面名称，作为打包产物文件名的一部分\n  pageName: string;\n  // 语言\n  lang: string;\n}\n\n\n例子:\n\n\n\nexport function pluginForDoc(): RspressPlugin {\n  return {\n    // 插件名称\n    name: 'plugin-routes',\n    // 在构建之后执行的钩子\n    async routeGenerated(routes) {\n      // 这里可以拿到 routes 数组，执行一些操作\n    },\n  };\n}\n","frontmatter":{}},{"id":57,"title":"编写一个插件","routePath":"/zh/plugin/system/write-a-plugin","lang":"zh","toc":[{"text":"1. 定义插件","id":"1-定义插件","depth":3,"charIndex":105},{"text":"2. 使用插件","id":"2-使用插件","depth":3,"charIndex":774}],"domain":"","content":"#\n\n我们以注入一个全局组件为例，来看看如何定义和使用插件。\n\n提示\n\n为了获得更好的类型提示，你可以在项目中安装 @rspress/shared，然后通过 `` 来引入 RspressPlugin 类型。\n\n\n1. 定义插件#\n\n\n\nexport function pluginExample(slug: string): RspressPlugin {\n  // 组件路径，组件的内容你需要自己实现\n  const componentPath = path.join(__dirname, 'Example.tsx');\n  return {\n    // 插件名称\n    name: 'plugin-example',\n    // 全局组件的路径\n    globalUIComponents: [componentPath],\n    // 构建阶段的全局变量定义\n    builderConfig: {\n      source: {\n        define: {\n          'process.env.slug': JSON.stringify(slug),\n        },\n      },\n    },\n  };\n}\n\n\n\n\nconst Example = () => {\n  console.log(process.env.SLUG);\n  return \nExample;\n};\n\nexport default Example;\n\n\n插件一般为一个函数，接收一些插件参数(可选)，返回一个对象，对象中包含插件的名称以及其它配置。在上面的例子中，我们定义了一个插件，它的名称为plugin-exa\nmple，它会在构建阶段定义一个全局变量slug，并且在文档中注入一个全局组件Example.tsx。\n\n\n2. 使用插件#\n\n在 rspress.config.ts 中通过 plugins 注册插件:\n\n\n\nexport default {\n  plugins: [pluginExample('test')],\n};\n\n\n这样，Example 组件会自动在页面中渲染，并且我们可以在 Example 组件中访问到process.env.slug。","frontmatter":{}}]